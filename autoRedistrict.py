# -*- coding: utf-8 -*-
"""
/***************************************************************************
 autoRedistrict
                                 A QGIS plugin
 Automatically splits areas into nearly equal segments
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-01-18
        git sha              : $Format:%H$
        copyright            : (C) 2020 by John Holden
        email                : redistricting@stattoconsulting.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.core import QgsSpatialIndex, QgsProject, QgsFeatureRequest, QgsExpression, QgsMessageLog
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .autoRedistrict_dialog import autoRedistrictDialog
import os.path

def sort_by_x(f):
    return f.geometry().centroid().asPoint().x()

def sort_by_y(f):
    return f.geometry().centroid().asPoint().y()

class autoRedistrict:
    """QGIS Plugin Implementation."""



    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'autoRedistrict_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Automated Redistricting')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        
        #initialise the other variables
        self.distfield = None
        self.popfield = None
        self.geofield = None
        self.activeLayer = None
        self.sortType = 0
        self.totalpop = 0
        self.targetpop = 0
        self.districts = 0
        self.sortIndex = 0
        self.spatialIndex = QgsSpatialIndex()
        self.distpop = []
        self.feature_dict = {}

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('autoRedistrict', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/autoRedistrict/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Auto Redistricting'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Automated Redistricting'),
                action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""

        #create the triggers - only need one

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = autoRedistrictDialog()
            
            self.dlg.cmbActiveLayer.currentIndexChanged.connect(self.updateFieldCombos)
            
            self.dlg.cmbDirection.clear()
            self.dlg.cmbDirection.addItems(['West to East','East to West','North to South','South to North'])

            
            self.updateDialog()

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            self.createVariables()
            self.initialiseSpatialIndex()
#            self.resetDistrictColumn()
            self.redistrictLayer()
                    
    def updateDialog(self):
        layers = [tree_layer.layer() for tree_layer in QgsProject.instance().layerTreeRoot().findLayers()]
        layer_list = []
        for layer in layers:
                layer_list.append(layer.name())
        self.dlg.cmbActiveLayer.clear()
        self.dlg.cmbActiveLayer.addItems(layer_list)
        
    def updateFieldCombos(self):
        self.dlg.cmbPopField.clear()
        self.dlg.cmbDistField.clear()
        self.dlg.cmbGeoField.clear()
#        activeDirectionIndex = self.dlg.cmbDirection.currentIndex()

        
        layers = [tree_layer.layer() for tree_layer in QgsProject.instance().layerTreeRoot().findLayers()]
        selectedLayerIndex = self.dlg.cmbActiveLayer.currentIndex()
        selectedLayer = layers[selectedLayerIndex]

        self.dlg.cmbGeoField.addItems(['None'])
        if hasattr(selectedLayer, 'fields'):
            fields = selectedLayer.fields()
            field_names = [field.name() for field in fields]
            self.dlg.cmbPopField.addItems(field_names)
            self.dlg.cmbDistField.addItems(field_names)
            self.dlg.cmbGeoField.addItems(field_names)

    def createVariables(self):
        self.iface.statusBarIface().showMessage( u"Creating variables..." )
        QCoreApplication.processEvents()
        self.popfield = self.dlg.cmbPopField.currentText()
        self.distfield = self.dlg.cmbDistField.currentText()
        self.geofield = self.dlg.cmbGeoField.currentText()
        self.sortIndex = self.dlg.cmbDirection.currentIndex()
        layers = [tree_layer.layer() for tree_layer in QgsProject.instance().layerTreeRoot().findLayers()]
        self.districts = self.dlg.inpDistricts.value()

        del self.distpop
        self.distpop = []
        self.distpop.append(0)

        selectedLayerIndex = self.dlg.cmbActiveLayer.currentIndex()
        selectedLayer = layers[selectedLayerIndex]
        self.activeLayer = selectedLayer

        for feature in self.activeLayer.getFeatures():
            self.totalpop = self.totalpop + int(feature[self.popfield])

        if self.districts > 0:
            self.targetpop = self.totalpop / self.districts
            print('districts:' + str(self.districts))
            print('targetpop:' + str(self.targetpop))
        else:
            pass
            
    def redistrictLayer(self):
        field_id = self.activeLayer.fields().indexFromName(self.distfield)
        self.iface.statusBarIface().showMessage( u"Redistricting layer..." )
        QCoreApplication.processEvents()

        districtctr = 0
        found = 0
        while found != -1:
            strExpr = "\"" + self.distfield + "\" = '0' or \"" + self.distfield + "\" = None"
            expr = QgsExpression(strExpr)
            
            if self.sortIndex == 1:
                # east to west
                features = sorted(self.activeLayer.getFeatures(strExpr), key=sort_by_x, reverse=True)
            elif self.sortIndex == 2:
                features = sorted(self.activeLayer.getFeatures(strExpr), key=sort_by_y, reverse=False)
            elif self.sortIndex == 3:
                features = sorted(self.activeLayer.getFeatures(strExpr), key=sort_by_y, reverse=True)
            else:
                features = sorted(self.activeLayer.getFeatures(strExpr), key=sort_by_x)
            found = 0
            for f in features:
                found = 1
                if f[self.distfield] == 0 or f[self.distfield] == None or f[self.distfield] == 'NULL':
                    print('New District:' + str(f['BLOCKID10']) + '|' + str(f[self.distfield]))
                    districtctr = districtctr + 1

                    """
                    if districtctr == 2:
                        strExpr = "\"" + self.distfield + "\" = '1'"
                        expr = QgsExpression(strExpr)
                        iterator = self.activeLayer.getFeatures(QgsFeatureRequest(expr))
                        ids = [i.id() for i in iterator]
                        self.activeLayer.select(ids)
                    """
                    print('New district being created:' + str(districtctr))
                    self.iface.statusBarIface().showMessage( u"Redistricting layer (starting district " + str(districtctr) + ")")
                    QCoreApplication.processEvents()
                    self.distpop.append(0)
                    is_enclave = self.floodFillDistrict(f, districtctr)
                    if is_enclave == 1:
                        districtctr = districtctr - 1
                    break
            if found == 0:
                #close the loop
                found = -1
        self.iface.statusBarIface().showMessage( u"...done.")


    def initialiseSpatialIndex(self):
        self.iface.statusBarIface().showMessage( u"Initialising spatial index..." )
        QCoreApplication.processEvents()
        self.feature_dict = {f.id(): f for f in self.activeLayer.getFeatures()}
        for f in list(self.feature_dict.values()):
            self.spatialIndex.addFeature(f)
            
    def resetDistrictColumn(self):
        self.iface.statusBarIface().showMessage( u"Clearing district column:" )
        QCoreApplication.processEvents()
        field_id = self.activeLayer.fields().indexFromName(self.distfield)

        self.activeLayer.startEditing()
        counter = 0
        request = QgsFeatureRequest().setFlags(QgsFeatureRequest.NoGeometry).setSubsetOfAttributes([self.distfield], self.activeLayer.fields())
        for f in self.activeLayer.getFeatures(request):
            counter = counter + 1
            self.activeLayer.changeAttributeValue(f.id(),field_id,0)
            if counter % 300 == 0:
                #speeds things up significantly
                self.activeLayer.commitChanges()
                self.activeLayer.startEditing()
                self.iface.statusBarIface().showMessage( u"Clearing district column: " + str(counter) + " records processed")
                QCoreApplication.processEvents()
        self.activeLayer.commitChanges()


    def floodFillDistrict(self, feature, district_number):
        QgsMessageLog.logMessage("Starting district " + str(district_number))
        print('district_number:' + str(district_number))
        field_id = self.activeLayer.fields().indexFromName(self.distfield)
        select_list = []
        outside_geo_list = []
        neighboring_districts = []
        if self.geofield != 'None':
            activeGeoField = feature[self.geofield]
            QgsMessageLog.logMessage("GeoField set to " + activeGeoField)
        geoCounter = 0
        self.distpop[district_number] = feature[self.popfield]
        self.activeLayer.startEditing()
        feature[self.distfield] = district_number
        self.activeLayer.changeAttributeValue(feature.id(),field_id,district_number,0)
        self.activeLayer.commitChanges()
        self.activeLayer.startEditing()
        print('starting at ' + str(feature.id()) + '|' + str(feature[self.distfield]), end=' ')
        select_list.append(feature)
        geoCounter = geoCounter + 1
        QCoreApplication.processEvents()
        surrounded = 0  #whether the feature is completely surrounded by another district
        # Loop through all features and find features that touch each feature
        counter = 0
        for f in select_list:
            geom = f.geometry()
            # Find all features that intersect the bounding box of the current feature.
            # We use spatial index to find the features intersecting the bounding box
            # of the current feature. This will narrow down the features that we need
            # to check neighboring features.
            intersecting_ids = self.spatialIndex.intersects(geom.boundingBox())
            counter = counter + 1
            if counter % 500 == 0:
                self.iface.statusBarIface().showMessage( u"Redistricting layer (district " + str(district_number) + ") " + str(counter) + " polygons added, current population " + str(self.distpop[district_number]) + "/" + str(self.targetpop))
                QCoreApplication.processEvents()
                self.activeLayer.commitChanges()
                self.activeLayer.startEditing()

            for intersecting_id in intersecting_ids:
                    # Look up the feature from the dictionary
                    intersecting_f = self.feature_dict[intersecting_id]
                    # For our purpose we consider a feature as 'neighbor' if it touches or
                    # intersects a feature. We use the 'disjoint' predicate to satisfy
                    # these conditions. So if a feature is not disjoint, it is a neighbor.
#                    if (f.id() != intersecting_f.id() and feature.id() != intersecting_f.id() and not intersecting_f.geometry().disjoint(geom)):
                    if (f.id() != intersecting_f.id() and feature.id() != intersecting_f.id() and intersecting_f.geometry().intersects(geom)):
                            if intersecting_f[self.distfield] == 0 or intersecting_f[self.distfield] == None:
                                if intersecting_f[self.geofield] == activeGeoField or self.geofield == 'None':
                                    if intersecting_f not in select_list:
                                            if surrounded != -1:
                                                surrounded = -1
                                            self.distpop[district_number] = self.distpop[district_number] + intersecting_f[self.popfield]
                                            intersecting_f[self.distfield] = district_number
                                            self.activeLayer.changeAttributeValue(intersecting_f.id(),field_id,district_number,0)
    #                                            print(':' + str(intersecting_f[self.distfield]), end=":")
                                            select_list.append(intersecting_f)
                                            geoCounter = geoCounter + 1
                                            if self.distpop[district_number] > self.targetpop:
                                                self.activeLayer.commitChanges()
                                                return 0
                                else:
                                    if intersecting_f not in outside_geo_list and intersecting_f not in select_list:
                                        outside_geo_list.append(intersecting_f)
                                        surrounded = -1
                            elif surrounded != -1:
                                #kill one-district, completely surrounded enclaves as we find them
                                if surrounded == 0:
                                    surrounded = intersecting_f[self.distfield]
                                elif surrounded != intersecting_f[self.distfield]:
                                    if surrounded > 0:
                                        neighboring_districts.append(surrounded)
                                    surrounded = -1
                            elif surrounded == -1:
                                if intersecting_f[self.distfield] not in neighboring_districts:
                                    neighboring_districts.append(intersecting_f[self.distfield])


                                """
                                #old code commented out which gets greedy and expands districts, but it doesn't work well - shoots down interstates, etc
                                if self.distpop[intersecting_f[self.distfield]] - intersecting_f[self.popfield] > self.targetpop:
                                    self.distpop[intersecting_f[self.distfield]] = self.distpop[intersecting_f[self.distfield]] - intersecting_f[self.popfield]
                                    self.distpop[district_number] = self.distpop[district_number] + intersecting_f[self.popfield]
                                    intersecting_f[self.distfield] = district_number
                                    self.activeLayer.changeAttributeValue(intersecting_f.id(),field_id,district_number,0)
                                    select_list.append(intersecting_f)
                                """

                                if self.distpop[district_number] > self.targetpop:
                                    self.activeLayer.commitChanges()
                                    return 0

            if surrounded > 0:
                QgsMessageLog.logMessage("enclave found, reassigning to district " + str(surrounded))
                self.activeLayer.changeAttributeValue(feature.id(),field_id,surrounded,0)
                self.distpop[district_number] = self.distpop[district_number] - feature[self.popfield]
                self.distpop[surrounded] = self.distpop[surrounded] + feature[self.popfield]
                self.activeLayer.commitChanges()
                return 1

            #if geoCounter is zero, this means we change the active geography
            geoCounter = geoCounter - 1
            activeGeoField = ''
            if geoCounter == 0 and self.geofield != 'None':
                for of in outside_geo_list:
                    if activeGeoField == '':
                        activeGeoField = of[self.geofield]
                        QgsMessageLog.logMessage("GeoField updated to " + activeGeoField)
                    if of[self.geofield] == activeGeoField:
                        select_list.append(of)
                        outside_geo_list.remove(of)
                        self.distpop[district_number] = self.distpop[district_number] + of[self.popfield]
                        of[self.distfield] = district_number
                        self.activeLayer.changeAttributeValue(of.id(),field_id,district_number,0)
                        geoCounter = geoCounter + 1

        if self.distpop[district_number] < (self.targetpop * (1 - 0.9)):
            new_district = 0
            lower_pop = -1
            for n in neighboring_districts:
                if self.distpop[n] > lower_pop or lower_pop == -1:
                    lower_pop = self.distpop[n]
                    new_district = n
            QgsMessageLog.logMessage("target population too low, reassigning to district " + str(new_district))
            for f in select_list:
                self.activeLayer.changeAttributeValue(f.id(),field_id,new_district,0)
                self.distpop[district_number] = self.distpop[district_number] - feature[self.popfield]
                self.distpop[new_district] = self.distpop[new_district] + feature[self.popfield]
            self.activeLayer.commitChanges()
            return 1

"""
                                                enclaves_only = 1
                                else:
                                    surrounded = -1
                                    break
                            else:
                                if (surrounded != intersecting_f[field_id] and surrounded != 0):
                                    surrounded = -1
                                    break
                                else:
                                    surrounded = intersecting_f[field_id]
            if enclaves_only == 1 and surrounded != -1 and (f[field_id] == 0 or f[field_id] == None):
                print('enclave found!!')
                self.distpop[district_number] = self.distpop[district_number] + f[self.popfield]
                self.activeLayer.changeAttributeValue(f.id(),field_id,district_number)
"""
